/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpc.h"

/* Check if user exist */
int user_exists(sqlite3 *db, char *user){
	int res=1; /* 1 true, 0 false*/
	char *zErrMsg = 0;
	int rc;
	/* We use this method instead of sprintf() to avoid sqlInjection*/
	char *query= sqlite3_mprintf("SELECT * FROM %q", user);

	rc = sqlite3_exec(db, query, NULL, 0, &zErrMsg);
	if( rc != SQLITE_OK ){
		res=0;
	}

	return res;
}

/*check if user is connected */
int user_connected(sqlite3 *db, char *user){
	int result=0; /* 1 true, 0 false*/
	int rc;
	
	sqlite3_stmt *res;

	char *sql = sqlite3_mprintf("SELECT * FROM USERS WHERE USER_NAME='%q' AND PORT IS NOT NULL", user);
    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);
    if(rc != SQLITE_OK){
       	fprintf(stderr, "Failed to execute statement: %s\n", sqlite3_errmsg(db));
	}
   	int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
		result = 1;
	}

	return result;
}
int file_exists(sqlite3 *db, char *file, char *user){
	int result=0; /* 1 true, 0 false*/
	int rc;
	
	sqlite3_stmt *res;

	char *sql = sqlite3_mprintf("SELECT * FROM %q WHERE FILE_NAME = '%q'", user, file);
    rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);
    if(rc != SQLITE_OK){
       	fprintf(stderr, "Failed to execute statement: %s\n", sqlite3_errmsg(db));
	}
   	int step = sqlite3_step(res);
    if (step == SQLITE_ROW) {
		result = 1;
	}

	return result;
}

bool_t
init_database_1_svc(void *result, struct svc_req *rqstp)
{
	bool_t retval;

	int rc;
	char *zErrMsg = 0;
	char * init_query="CREATE TABLE USERS("  \
      "USER_NAME TEXT PRIMARY KEY     NOT NULL," \
	  "IP    TEXT," \
	  "PORT TEXT);";

	remove("database.db");
	rc = sqlite3_open("database.db", &db);
   	if(rc) {
   	   fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
   	   return;
   	}

	rc = sqlite3_exec(db, init_query, NULL, 0, &zErrMsg);
	if( rc != SQLITE_OK ){
      fprintf(stderr, "SQL error: %s\n", zErrMsg);
      sqlite3_free(zErrMsg);
   	}

	return retval;
}

bool_t
my_register_1_svc(char *user_name, char *result,  struct svc_req *rqstp)
{
	bool_t retval = 0;

	int rc;
	char code = '2';
	char *zErrMsg = 0;
	/* We use this method instead of sprintf() to avoid sqlInjection*/
	char *query= sqlite3_mprintf("INSERT INTO USERS(USER_NAME) VALUES('%q');", user_name);
	rc = sqlite3_exec(db, query, NULL, 0, &zErrMsg);
	if( rc != SQLITE_OK ){
		if(strstr(zErrMsg,"SQL error: UNIQUE constraint failed: USERS.USER_NAME") == 0){
			/*If we are here in means that user is already in database so in cannot connect again*/
			code = '1';
		}else{
			code = '2';
			fprintf(stderr, "SQL error: %s\n", zErrMsg);
		}
		*result = code;
		return retval;
   	}
	/* If there are not errors we create one table for the user*/
	query= sqlite3_mprintf("CREATE TABLE %q("  \
    "FILE_NAME TEXT PRIMARY KEY   NOT NULL,"\
	"FILE_DESCRIPTION TEXT NOT NULL);", user_name);
	rc = sqlite3_exec(db, query, NULL, 0, &zErrMsg);
	if( rc != SQLITE_OK ){
     	fprintf(stderr, "SQL error: %s\n", zErrMsg);
      	sqlite3_free(zErrMsg);
		code = '2';
		fprintf(stderr, "SQL error: %s\n", zErrMsg);
		*result = code;
		return retval;
	}
	*result = code;
	return retval;
}

bool_t
unregister_1_svc(char *user_name, char *result,  struct svc_req *rqstp)
{
	bool_t retval = 0;

	int rc;
	char code = '2';
	char *zErrMsg = 0;
	/* We use this method instead of sprintf() to avoid sqlInjection*/
	char * query= sqlite3_mprintf("DROP TABLE %q;", user_name);
	/* We delete the table*/
	rc = sqlite3_exec(db, query, NULL, 0, &zErrMsg);
	if( rc != SQLITE_OK ){
		if(strstr(zErrMsg, "no such table")){ 
			code = '1';
		}else{
			fprintf(stderr, "SQL error: %s\n", zErrMsg);
			code = '2';
		}
    	sqlite3_free(zErrMsg);
		*result = code;
		return retval;
   	}
	query= sqlite3_mprintf("DELETE FROM USERS WHERE USER_NAME='%q';", user_name);
	rc = sqlite3_exec(db, query, NULL, 0, &zErrMsg);
	if( rc != SQLITE_OK ){
    	sqlite3_free(zErrMsg);
		code = '2';
		fprintf(stderr, "SQL error: %s\n", zErrMsg);
		*result = code;
		return retval;
	}
	*result = code;
	return retval;
}

bool_t
publish_1_svc(char *user_name, char *file_name, char *file_description, char *result,  struct svc_req *rqstp)
{
	bool_t retval = 0;

	int rc;
	char code = '4';
	char *zErrMsg = 0;
	if(user_exists(db, user_name) == 0){
		code = '1';
	}else if(user_connected(db, user_name) == 0){
		code = '2';
	}else if(file_exists(db, file_name,user_name) == 1){
		code = '3';
	}else{
		char *query= sqlite3_mprintf("INSERT INTO %q(FILE_NAME, FILE_DESCRIPTION) VALUES('%q', '%q');",user_name, file_name, file_description);
		rc = sqlite3_exec(db, query, NULL, 0, &zErrMsg);
		if( rc != SQLITE_OK ){
			fprintf(stderr, "SQL error: %s\n", zErrMsg);
    		sqlite3_free(zErrMsg);
			code = '4';
   		}else{
			code='0';
		}
	}
	*result = code;
	return retval;
}

bool_t
my_delete_1_svc(char *user_name, char *file_name, char *result,  struct svc_req *rqstp)
{
	bool_t retval = 0;

	int rc;
	char code = '4';
	char *zErrMsg = 0;
	if(user_exists(db, user_name) == 0){
		code = '1';
	}else if(user_connected(db, user_name) == 0){
		code = '2';
	}else if(file_exists(db, file_name,user_name) == 0){
		code = '3';
	}else{
		char *query= sqlite3_mprintf("DELETE FROM %q WHERE FILE_NAME='%q';",user_name, file_name);
		rc = sqlite3_exec(db, query, NULL, 0, &zErrMsg);
		if( rc != SQLITE_OK ){
			fprintf(stderr, "SQL error: %s\n", zErrMsg);
        	sqlite3_free(zErrMsg);
			code = '4';
   		}else{
			code = '0';
		}
	}
	*result = code;
	return retval;
}

bool_t
my_connect_1_svc(char *user_name, char *clientip, char *client_port, char *result,  struct svc_req *rqstp)
{
	bool_t retval = 0;

	int rc;
	char code = '3';
	char *zErrMsg = 0;
	if(user_exists(db, user_name) == 0){
		code = '1';
	}else if(user_connected(db, user_name) == 1){
		code = '2';
	}else{
		/* We use this method instead of sprintf() to avoid sqlInjection*/
		char *query= sqlite3_mprintf("UPDATE USERS SET PORT = '%q', IP = '%q'  WHERE USER_NAME = '%q'",client_port,clientip,user_name);
		puts(query);
		rc = sqlite3_exec(db, query, NULL, 0, &zErrMsg);
		if( rc != SQLITE_OK ){
			fprintf(stderr, "SQL error: %s\n", zErrMsg);
    		sqlite3_free(zErrMsg);
			code = '3';
		}else{
			code = '0';
		}
	}
	*result = code;
	return retval;

}

bool_t
disconnect_1_svc(char *user_name, char *result,  struct svc_req *rqstp)
{
	bool_t retval = 0;

	int rc;
	char code = '3';
	char *zErrMsg = 0;
	if(user_exists(db, user_name) == 0){
		code = '1';
	}else if(user_connected(db, user_name) == 0){
		code = '2';
	}else{
		/* We use this method instead of sprintf() to avoid sqlInjection*/
		char *query= sqlite3_mprintf("UPDATE USERS SET PORT = NULL WHERE USER_NAME = '%q'",user_name);
		rc = sqlite3_exec(db, query, NULL, 0, &zErrMsg);
		if( rc != SQLITE_OK ){
			fprintf(stderr, "SQL error: %s\n", zErrMsg);
			sqlite3_free(zErrMsg);
			code = '3';
		}else{
			code='0';
		}	
   	}
	*result = code;
	return retval;
}

bool_t
list_users_1_svc(char *user_name, ruser *result,  struct svc_req *rqstp)
{
	bool_t retval;
	char *zErrMsg = 0;
	int num_users=0;
	char buf[256];

	if(user_exists(db, user_name) == 0){
		code = '1';
	}else if(user_connected(db, user_name) == 0){
		code = '2';
	}else{
		/*FIRST WE RETRIEVE THE NUMBER OF THE USERS WITH COUNT*/
		char * query= "SELECT COUNT(*) FROM USERS WHERE PORT IS NOT NULL";
		printf("%s",query);
		rc = SQLITE_OK;//sqlite3_exec(db, query, count_rows, &num_users, &zErrMsg);
		if( rc != SQLITE_OK ){
			code = '3';
			fprintf(stderr, "SQL error: %s\n", zErrMsg);
		}else {
			sqlite3_stmt *res;

			char *sql = "SELECT * FROM USERS WHERE PORT IS NOT NULL";
			rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);
			if(rc != SQLITE_OK){
				code = '3';
				fprintf(stderr, "Failed to execute statement: %s\n", sqlite3_errmsg(db));
			}else{
				code = '0';

				result->l->user_len = num_users;

				int step = sqlite3_step(res);
				struct user * us = result->l->user_val;

				while (step == SQLITE_ROW) {

					sprintf(buf, "%s", sqlite3_column_text(res, 0));
					strcpy(user->name, &buf);

					sprintf(buf, "%s", sqlite3_column_text(res, 1));
					strcpy(us->ip, &buf);

					sprintf(buf, "%s", sqlite3_column_text(res, 2));
					strcpy(us->port, &buf);

					step = sqlite3_step(res);
					us++;
				}
			}
		}
	}
	result->err = code;
	//result->l = list_users;
	return retval;
}

bool_t
list_content_1_svc(char *user_name, rcontent *result,  struct svc_req *rqstp)
{
	bool_t retval;

	char buf[256];
	char *zErrMsg = 0;
	
	char user_content[256];
	readLine(s_local,user_content, sizeof(user_content));

	if(user_exists(db, user_name) == 0){
		code = '1';
	}else if(user_connected(db, user_name) == 0){
		code = '2';
	}else if(user_exists(db, user_content) == 0){
		code = '3';
	}else {
		int num_content=0;
		char * query = sqlite3_mprintf("SELECT COUNT(*) FROM %q",user_content);

		rc = SQLITE_OK;//sqlite3_exec(db, query, count_rows, &num_content, &zErrMsg);
		printf("%s",query);
		if( rc != SQLITE_OK ){
			fprintf(stderr, "SQL error: %s\n", zErrMsg);
		}
		
		sqlite3_stmt *res;
		
		char *sql = sqlite3_mprintf("SELECT * FROM %q", user_content ) ;
		rc = sqlite3_prepare_v2(db, sql, -1, &res, 0);
		if(rc != SQLITE_OK){
			fprintf(stderr, "Failed to execute statement: %s\n", sqlite3_errmsg(db));
		}

		code = '0';

		result->l->content_len = num_content;
		struct content * cont = result->l->content_val;
		int step = sqlite3_step(res);
		while(step == SQLITE_ROW) {
			
			sprintf(buf, "%s", sqlite3_column_text(res, 0));
			//Copy the file name into the struct result
			strcpy(cont->fileName, &buf);
			step = sqlite3_step(res);
			cont++;
		}
	}
	result->err = code;
	return retval;
}

int
prog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
